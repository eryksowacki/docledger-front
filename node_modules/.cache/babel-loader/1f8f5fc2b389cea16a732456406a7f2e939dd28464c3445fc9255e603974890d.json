{"ast":null,"code":"// src/documentService.ts\nimport{apiFetch}from\"./api\";function buildQuery(params){const qs=new URLSearchParams();Object.entries(params).forEach(_ref=>{let[k,v]=_ref;if(v!==undefined&&v!==\"\")qs.set(k,v);});const s=qs.toString();return s?\"?\".concat(s):\"\";}/**\n * Backend może zwracać:\n * - [] (idealnie)\n * - { data: [] } (Laravel Resource / paginator)\n * - { items: [] } / { rows: [] } (custom)\n *\n * Ta funkcja zawsze zwróci TABLICĘ, żeby .map() nie wybuchał.\n */function unwrapList(payload){if(Array.isArray(payload))return payload;if(payload&&Array.isArray(payload.data))return payload.data;if(payload&&Array.isArray(payload.items))return payload.items;if(payload&&Array.isArray(payload.rows))return payload.rows;// w dev warto zobaczyć co przyszło\nconsole.warn(\"Expected array from API, got:\",payload);return[];}export async function listDocuments(){let query=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const q=buildQuery({type:query.type,status:query.status});const res=await apiFetch(\"/api/documents\".concat(q));return unwrapList(res);}export async function createDocument(payload){return apiFetch(\"/api/documents\",{method:\"POST\",body:JSON.stringify(payload)});}export async function bookDocument(id){return apiFetch(\"/api/documents/\".concat(id,\"/book\"),{method:\"POST\"});}export async function listLedger(){const res=await apiFetch(\"/api/ledger\");return unwrapList(res);}","map":{"version":3,"names":["apiFetch","buildQuery","params","qs","URLSearchParams","Object","entries","forEach","_ref","k","v","undefined","set","s","toString","concat","unwrapList","payload","Array","isArray","data","items","rows","console","warn","listDocuments","query","arguments","length","q","type","status","res","createDocument","method","body","JSON","stringify","bookDocument","id","listLedger"],"sources":["/var/www/web-szyper/src/documentService.ts"],"sourcesContent":["// src/documentService.ts\nimport { apiFetch } from \"./api\";\nimport type {\n    DocumentRow,\n    DocumentCreateRequest,\n    DocumentCreateResponse,\n    DocumentBookResponse,\n    DocumentListQuery,\n    LedgerRow,\n} from \"./types\";\n\nfunction buildQuery(params: Record<string, string | undefined>) {\n    const qs = new URLSearchParams();\n    Object.entries(params).forEach(([k, v]) => {\n        if (v !== undefined && v !== \"\") qs.set(k, v);\n    });\n    const s = qs.toString();\n    return s ? `?${s}` : \"\";\n}\n\n/**\n * Backend może zwracać:\n * - [] (idealnie)\n * - { data: [] } (Laravel Resource / paginator)\n * - { items: [] } / { rows: [] } (custom)\n *\n * Ta funkcja zawsze zwróci TABLICĘ, żeby .map() nie wybuchał.\n */\nfunction unwrapList<T>(payload: any): T[] {\n    if (Array.isArray(payload)) return payload;\n\n    if (payload && Array.isArray(payload.data)) return payload.data;\n    if (payload && Array.isArray(payload.items)) return payload.items;\n    if (payload && Array.isArray(payload.rows)) return payload.rows;\n\n    // w dev warto zobaczyć co przyszło\n    console.warn(\"Expected array from API, got:\", payload);\n    return [];\n}\n\nexport async function listDocuments(query: DocumentListQuery = {}): Promise<DocumentRow[]> {\n    const q = buildQuery({\n        type: query.type,\n        status: query.status,\n    });\n\n    const res = await apiFetch<any>(`/api/documents${q}`);\n    return unwrapList<DocumentRow>(res);\n}\n\nexport async function createDocument(payload: DocumentCreateRequest): Promise<DocumentCreateResponse> {\n    return apiFetch<DocumentCreateResponse>(\"/api/documents\", {\n        method: \"POST\",\n        body: JSON.stringify(payload),\n    });\n}\n\nexport async function bookDocument(id: number): Promise<DocumentBookResponse> {\n    return apiFetch<DocumentBookResponse>(`/api/documents/${id}/book`, {\n        method: \"POST\",\n    });\n}\n\nexport async function listLedger(): Promise<LedgerRow[]> {\n    const res = await apiFetch<any>(\"/api/ledger\");\n    return unwrapList<LedgerRow>(res);\n}"],"mappings":"AAAA;AACA,OAASA,QAAQ,KAAQ,OAAO,CAUhC,QAAS,CAAAC,UAAUA,CAACC,MAA0C,CAAE,CAC5D,KAAM,CAAAC,EAAE,CAAG,GAAI,CAAAC,eAAe,CAAC,CAAC,CAChCC,MAAM,CAACC,OAAO,CAACJ,MAAM,CAAC,CAACK,OAAO,CAACC,IAAA,EAAY,IAAX,CAACC,CAAC,CAAEC,CAAC,CAAC,CAAAF,IAAA,CAClC,GAAIE,CAAC,GAAKC,SAAS,EAAID,CAAC,GAAK,EAAE,CAAEP,EAAE,CAACS,GAAG,CAACH,CAAC,CAAEC,CAAC,CAAC,CACjD,CAAC,CAAC,CACF,KAAM,CAAAG,CAAC,CAAGV,EAAE,CAACW,QAAQ,CAAC,CAAC,CACvB,MAAO,CAAAD,CAAC,KAAAE,MAAA,CAAOF,CAAC,EAAK,EAAE,CAC3B,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAAS,CAAAG,UAAUA,CAAIC,OAAY,CAAO,CACtC,GAAIC,KAAK,CAACC,OAAO,CAACF,OAAO,CAAC,CAAE,MAAO,CAAAA,OAAO,CAE1C,GAAIA,OAAO,EAAIC,KAAK,CAACC,OAAO,CAACF,OAAO,CAACG,IAAI,CAAC,CAAE,MAAO,CAAAH,OAAO,CAACG,IAAI,CAC/D,GAAIH,OAAO,EAAIC,KAAK,CAACC,OAAO,CAACF,OAAO,CAACI,KAAK,CAAC,CAAE,MAAO,CAAAJ,OAAO,CAACI,KAAK,CACjE,GAAIJ,OAAO,EAAIC,KAAK,CAACC,OAAO,CAACF,OAAO,CAACK,IAAI,CAAC,CAAE,MAAO,CAAAL,OAAO,CAACK,IAAI,CAE/D;AACAC,OAAO,CAACC,IAAI,CAAC,+BAA+B,CAAEP,OAAO,CAAC,CACtD,MAAO,EAAE,CACb,CAEA,MAAO,eAAe,CAAAQ,aAAaA,CAAA,CAAwD,IAAvD,CAAAC,KAAwB,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAhB,SAAA,CAAAgB,SAAA,IAAG,CAAC,CAAC,CAC7D,KAAM,CAAAE,CAAC,CAAG5B,UAAU,CAAC,CACjB6B,IAAI,CAAEJ,KAAK,CAACI,IAAI,CAChBC,MAAM,CAAEL,KAAK,CAACK,MAClB,CAAC,CAAC,CAEF,KAAM,CAAAC,GAAG,CAAG,KAAM,CAAAhC,QAAQ,kBAAAe,MAAA,CAAuBc,CAAC,CAAE,CAAC,CACrD,MAAO,CAAAb,UAAU,CAAcgB,GAAG,CAAC,CACvC,CAEA,MAAO,eAAe,CAAAC,cAAcA,CAAChB,OAA8B,CAAmC,CAClG,MAAO,CAAAjB,QAAQ,CAAyB,gBAAgB,CAAE,CACtDkC,MAAM,CAAE,MAAM,CACdC,IAAI,CAAEC,IAAI,CAACC,SAAS,CAACpB,OAAO,CAChC,CAAC,CAAC,CACN,CAEA,MAAO,eAAe,CAAAqB,YAAYA,CAACC,EAAU,CAAiC,CAC1E,MAAO,CAAAvC,QAAQ,mBAAAe,MAAA,CAAyCwB,EAAE,UAAS,CAC/DL,MAAM,CAAE,MACZ,CAAC,CAAC,CACN,CAEA,MAAO,eAAe,CAAAM,UAAUA,CAAA,CAAyB,CACrD,KAAM,CAAAR,GAAG,CAAG,KAAM,CAAAhC,QAAQ,CAAM,aAAa,CAAC,CAC9C,MAAO,CAAAgB,UAAU,CAAYgB,GAAG,CAAC,CACrC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}